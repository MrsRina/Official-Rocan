package me.rina.rocan.client.module.exploit;

import me.rina.rocan.Rocan;
import me.rina.rocan.api.module.Module;
import me.rina.rocan.api.module.impl.ModuleCategory;
import me.rina.rocan.api.module.registry.Registry;
import me.rina.rocan.api.setting.value.ValueBoolean;
import me.rina.rocan.api.setting.value.ValueEnum;
import me.rina.rocan.api.setting.value.ValueNumber;
import me.rina.rocan.api.tracker.Tracker;
import me.rina.rocan.api.tracker.impl.PlayerAbortBreakBlockTracker;
import me.rina.rocan.api.tracker.impl.PlayerStartBreakBlockTracker;
import me.rina.rocan.api.tracker.impl.PlayerStopBreakBlockTracker;
import me.rina.rocan.api.util.chat.ChatUtil;
import me.rina.rocan.api.util.client.FlagBoolUtil;
import me.rina.rocan.api.util.client.KeyUtil;
import me.rina.rocan.api.util.client.NullUtil;
import me.rina.rocan.api.util.crystal.BlockUtil;
import me.rina.rocan.api.util.item.ItemUtil;
import me.rina.rocan.api.util.math.PositionUtil;
import me.rina.rocan.api.util.render.Render3DUtil;
import me.rina.rocan.client.event.client.ClientTickEvent;
import me.rina.rocan.client.event.entity.PlayerDamageBlockEvent;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener;

import java.awt.*;
import java.util.ArrayList;

/**
 * @author SrRina
 * @since 08/02/2021 at 11:34
 **/
@Registry(name = "Better Mine", tag = "BetterMine", description = "Make your mining better than normal.", category = ModuleCategory.EXPLOIT)
public class ModuleBetterMine extends Module {
    public static ValueEnum settingBreakMode = new ValueEnum("Break Mode", "BreakMode", "How client break the blocks.", Mode.PACKET);
    public static ValueNumber settingPacketDelay = new ValueNumber("Packet Delay", "PacketDelay", "The MS delay for sending packet.", 250, 0,  500);

    public static ValueEnum settingQueue = new ValueEnum("Queue", "Queue", "Enable queue to break blocks.", FlagBoolUtil.TRUE);
    public static ValueBoolean settingPriority = new ValueBoolean("Priority", "Priority", "Priority next block to break if ray trace is out.", true);
    public static ValueNumber settingQueueLimit = new ValueNumber("Queue Limit", "QueueLimit", "Stop queue at limit.", 6, 1, 10);

    public static ValueBoolean settingNoEntityTrace = new ValueBoolean("No Entity Trace", "NoEntityTrace", "Ignore hit entity.", true);
    public static ValueBoolean settingOnlyPickaxe = new ValueBoolean("Only Pickaxe", "OnlyPickaxe", "Only pickaxe at hand to starts break.", true);
    public static ValueNumber settingRange = new ValueNumber("Range", "Range", "Ray trace range.", 4.5f, 1f, 5f);

    public static ValueBoolean settingSwingAnimation = new ValueBoolean("Swing Animation", "SwingAnimation", "Swing hand animation.", false);
    public static ValueBoolean settingReset = new ValueBoolean("Reset", "Reset", "Reset damage when is mining another block.", true);

    public static ValueBoolean settingRGB = new ValueBoolean("RGB", "RGB", "RGB effect.", false);

    public static ValueNumber settingRed = new ValueNumber("Red", "Red", "Color line range red.", 0, 0, 255);
    public static ValueNumber settingGreen = new ValueNumber("Green", "Green", "Color line range green.", 0, 0, 255);
    public static ValueNumber settingBlue = new ValueNumber("Blue", "Blue", "Color line range blue.", 0, 0, 255);
    public static ValueNumber renderAlpha = new ValueNumber("Alpha", "Alpha", "Color line range alpha.", 100, 0, 255);

    public static ValueEnum renderOutline = new ValueEnum("Outline", "Outline", "Outline effect.", RenderOutline.Enabled);

    enum RenderOutline {
        Enabled, Disabled;
    }

    public static ValueNumber settingOutlineLineSize = new ValueNumber("Outline Line Size", "OutlineLineSize", "Line size.", 1.0f, 1f, 3.0f);
    public static ValueBoolean settingOutlineRGB = new ValueBoolean("Outline RGB", "OutlineRGB", "360 color range.", false);

    public static ValueNumber settingOutlineRed = new ValueNumber("Outline Red", "OutlineRed", "Color line range red.", 255, 0, 255);
    public static ValueNumber settingOutlineGreen = new ValueNumber("Outline Green", "OutlineGreen", "Color line range green.", 255, 0, 255);
    public static ValueNumber settingOutlineBlue = new ValueNumber("Outline Blue", "OutlineBlue", "Color line range blue.", 255, 0, 255);
    public static ValueNumber settingOutlineAlpha = new ValueNumber("Outline Alpha", "OutlineAlpha", "Color line range alpha.", 255, 0, 255);

    private boolean hasPickaxe;
    private boolean isBreaking;

    private ArrayList<BlockUtil.BlockDamage> blocksToBreak = new ArrayList<>();
    private Tracker tracker = new Tracker("Tracker for Better Mine").inject();

    public enum Mode {
        PACKET, DAMAGE;
    }

    @Override
    public void onSetting() {
        settingPacketDelay.setEnabled(settingBreakMode.getValue() == Mode.PACKET);
        settingQueue.setEnabled(settingBreakMode.getValue() == Mode.PACKET);

        settingReset.setEnabled(settingBreakMode.getValue() == Mode.PACKET && settingQueue.getValue() == FlagBoolUtil.TRUE || settingBreakMode.getValue() == Mode.DAMAGE);
        settingSwingAnimation.setEnabled(settingBreakMode.getValue() == Mode.DAMAGE);

        settingPriority.setEnabled(settingQueue.getValue() == FlagBoolUtil.TRUE && settingBreakMode.getValue() == Mode.PACKET);
        settingQueueLimit.setEnabled(settingQueue.getValue() == FlagBoolUtil.TRUE && settingBreakMode.getValue() == Mode.PACKET);
        settingOnlyPickaxe.setEnabled(settingNoEntityTrace.getValue());
        settingRange.setEnabled(settingNoEntityTrace.getValue());

        settingOutlineLineSize.setEnabled(renderOutline.getValue() == RenderOutline.Enabled);
        settingOutlineRed.setEnabled(renderOutline.getValue() == RenderOutline.Enabled);
        settingOutlineGreen.setEnabled(renderOutline.getValue() == RenderOutline.Enabled);
        settingOutlineBlue.setEnabled(renderOutline.getValue() == RenderOutline.Enabled);
        settingOutlineAlpha.setEnabled(renderOutline.getValue() == RenderOutline.Enabled);
        settingOutlineRGB.setEnabled(renderOutline.getValue() == RenderOutline.Enabled);

        if (settingRGB.getValue()) {
            settingRed.setValue(Rocan.getClientEventManager().getCurrentRGBColor()[0]);
            settingGreen.setValue(Rocan.getClientEventManager().getCurrentRGBColor()[1]);
            settingBlue.setValue(Rocan.getClientEventManager().getCurrentRGBColor()[2]);
        }

        if (settingOutlineRGB.getValue()) {
            settingOutlineRed.setValue(Rocan.getClientEventManager().getCurrentRGBColor()[0]);
            settingOutlineGreen.setValue(Rocan.getClientEventManager().getCurrentRGBColor()[1]);
            settingOutlineBlue.setValue(Rocan.getClientEventManager().getCurrentRGBColor()[2]);
        }

        /*
         * We set the delay for packet tracker.
         */
        this.tracker.setDelay(settingPacketDelay.isEnabled() ? settingPacketDelay.getValue().intValue() : 0);
    }

    @Listener
    public void onListenPlayerDamageBlock(PlayerDamageBlockEvent event) {
        if (settingNoEntityTrace.getValue() == false) {
            this.doAdd(event.getPos(), event.getFacing());
        }
    }

    @Listener
    public void onListen(ClientTickEvent event) {
        if (NullUtil.isPlayerWorld()) {
            return;
        }

        // the flag pickaxe works only for no entity trace,
        this.hasPickaxe = settingOnlyPickaxe.getValue() ? ItemUtil.contains(ItemUtil.ALL_PICKAXES, mc.player.getHeldItemMainhand().getItem()) : true;

        // We verify the raytrace object.
        RayTraceResult rayTraceBlock = mc.player.rayTrace(settingRange.getValue().floatValue(), mc.getRenderPartialTicks());

        // So wee verify if entity hit.
        if (rayTraceBlock != null && rayTraceBlock.typeOfHit == RayTraceResult.Type.BLOCK && settingNoEntityTrace.getValue()) {
            BlockPos pos = rayTraceBlock.getBlockPos();

            // Is not air and there is flag pickaxe.
            if (this.hasPickaxe && (mc.gameSettings.keyBindAttack.pressed || KeyUtil.isPressed(mc.gameSettings.keyBindAttack))) {
                this.doAdd(pos, rayTraceBlock.sideHit);
            }
        }

        // Clear.
        if ((settingReset.isEnabled() && settingReset.getValue()) && this.blocksToBreak.size() >= 2) {
            this.blocksToBreak.clear();
        }

        if (this.blocksToBreak.isEmpty()) {
            this.tracker.clear();
        }

        for (BlockUtil.BlockDamage blocks : new ArrayList<>(this.blocksToBreak)) {
            // So its the limit, remove the last block and go to next block.
            if (settingQueueLimit.isEnabled() && this.blocksToBreak.size() >= settingQueueLimit.getValue().intValue()) {
                this.blocksToBreak.remove(blocks);

                continue;
            }

            float flag = BlockUtil.getHardness(blocks.getPos());

            if (flag != -1 && flag != 0) {
                // Priority system to main blocks added.
                if ((settingPriority.isEnabled() && settingPriority.getValue() && BlockUtil.getDistanceI(blocks.getPos(), mc.player) >= 5) || BlockUtil.getDistanceI(blocks.getPos(), mc.player) >= 6) {
                    if (settingBreakMode.getValue() == Mode.PACKET) {
                        // We need to abort break.
                        this.tracker.send(new PlayerAbortBreakBlockTracker(blocks));
                        this.isBreaking = true;
                    }

                    // Remove from list.
                    this.blocksToBreak.remove(blocks);

                    continue;
                }

                this.doBreak(blocks);
            } else {
                this.isBreaking = true;
                this.tracker.clear();
                // Next block.
                this.blocksToBreak.remove(blocks);
            }
        }
    }

    @Override
    public void onRender3D() {
        if (NullUtil.isPlayerWorld()) {
            return;
        }

        this.print("" + this.blocksToBreak.size());

        Color color = new Color(settingRed.getValue().intValue(), settingGreen.getValue().intValue(), settingBlue.getValue().intValue(), renderAlpha.getValue().intValue());
        Color colorOutline = new Color(settingOutlineRed.getValue().intValue(), settingOutlineGreen.getValue().intValue(), settingOutlineBlue.getValue().intValue(), settingOutlineAlpha.getValue().intValue());

        for (BlockUtil.BlockDamage blocks : this.blocksToBreak) {
            Render3DUtil.render3DSolid(camera, blocks.getPos(), color);

            if (renderOutline.getValue() == RenderOutline.Enabled) {
                float line = (float) settingOutlineLineSize.getValue();

                Render3DUtil.render3DOutline(camera, blocks.getPos(), line, colorOutline);
            }
        }
    }

    @Override
    public void onEnable() {
        this.tracker.register();
        this.tracker.clear();
    }

    @Override
    public void onDisable() {
        this.blocksToBreak.clear();
        this.tracker.unregister();
        this.tracker.clear();
    }

    public void doAdd(BlockPos pos, EnumFacing facing) {
        BlockUtil.BlockDamage block = new BlockUtil.BlockDamage(pos, facing);

        if (settingQueueLimit.isEnabled()) {
            // If queue size is hitting we cancel the request.
            if (this.blocksToBreak.size() >= settingQueueLimit.getValue().intValue()) {
                return;
            }

            // Verify if already exists.
            if (this.contains(block.getPos()) == false) {
                this.tracker.clear();
                this.blocksToBreak.add(block);
            }
        } else {
            if (this.contains(block.getPos()) && this.blocksToBreak.size() > 1) {
                return;
            }

            // Verify.
            if (this.contains(block.getPos()) == false) {
                this.tracker.clear();

                // Cancel another block breaks.
                if (settingReset.getValue()) {
                    this.blocksToBreak.clear();
                }

                this.blocksToBreak.add(block);
            }
        }
    }

    public void doBreak(BlockUtil.BlockDamage block) {
        switch ((Mode) settingBreakMode.getValue()) {
            case DAMAGE: {
                if (settingSwingAnimation.getValue()) {
                    mc.player.swingArm(EnumHand.MAIN_HAND);
                }

                mc.playerController.onPlayerDamageBlock(block.getPos(), block.getFacing());

                break;
            }

            case PACKET: {
                // So we send to tracker the queue.
                this.tracker.join(new PlayerStartBreakBlockTracker(EnumHand.MAIN_HAND, block));
                this.tracker.join(new PlayerStopBreakBlockTracker(block));

                break;
            }
        }
    }

    public boolean contains(BlockPos pos) {
        for (BlockUtil.BlockDamage blocks : this.blocksToBreak) {
            if (PositionUtil.collideBlockPos(pos, blocks.getPos())) {
                return true;
            }
        }

        return false;
    }
}