package me.rina.rocan.client.module.exploit;

import me.rina.rocan.api.module.Module;
import me.rina.rocan.api.module.impl.ModuleCategory;
import me.rina.rocan.api.module.registry.Registry;
import me.rina.rocan.api.setting.value.ValueBoolean;
import me.rina.rocan.api.setting.value.ValueEnum;
import me.rina.rocan.api.setting.value.ValueNumber;
import me.rina.rocan.api.tracker.Tracker;
import me.rina.rocan.api.tracker.impl.PlayerAbortBreakBlockTracker;
import me.rina.rocan.api.tracker.impl.PlayerStartBreakBlockTracker;
import me.rina.rocan.api.tracker.impl.PlayerStopBreakBlockTracker;
import me.rina.rocan.api.util.client.NullUtil;
import me.rina.rocan.api.util.crystal.BlockUtil;
import me.rina.rocan.api.util.entity.PlayerUtil;
import me.rina.rocan.api.util.item.ItemUtil;
import me.rina.rocan.api.util.math.PositionUtil;
import me.rina.rocan.api.util.render.RenderUtil;
import me.rina.rocan.client.event.client.ClientTickEvent;
import me.rina.rocan.client.event.entity.PlayerDamageBlockEvent;
import me.rina.rocan.client.module.client.ModuleAntiCheat;
import net.minecraft.entity.Entity;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import me.rina.rocan.api.util.crystal.BlockUtil.BlockDamage;
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener;

import java.awt.*;
import java.util.ArrayList;

/**
 * @author SrRina
 * @since 27/02/2021 at 15:26
 **/
@Registry(name = "Better Mine", tag = "BetterMine", description = "Make your mining better!", category = ModuleCategory.EXPLOIT)
public class ModuleBetterMine extends Module {
    /* Main settings. */
    public static ValueBoolean settingOnlyPickaxe = new ValueBoolean("Only Pickaxe", "OnlyPickaxe", "Uses better mine only with pickaxe.", false);
    public static ValueBoolean settingNoEntityTrace = new ValueBoolean("No Entity Trace", "NoEntityTrace", "Bypass entity hit to mines.", true);

    /* Break modes. */
    public static ValueEnum settingBreakMode = new ValueEnum("Break Mode", "BreakMode", "Break modes to better mine.", BreakMode.DAMAGE);

    /* Break packet setting. */
    public static ValueNumber settingPacketDelay = new ValueNumber("Packet Delay", "Packet Delay", "Preserve anti spam packets putting delay.", 50, 0, 250);

    public enum BreakMode {
        PACKET, DAMAGE;
    }

    /* Queue. */
    public static ValueBoolean settingQueue = new ValueBoolean("Queue", "Queue", "A system queue to break blocks.", false);

    /* Queue true settings. */
    public static ValueNumber settingQueueLimit = new ValueNumber("Queue Limit", "QueueLimit", "Preserve blocks limit to break.", 6, 2, 10);

    private ArrayList<BlockDamage> queue;
    private Tracker tracker = new Tracker("BetterMineTracker").inject();

    private float currentBlockDamageMP;

    public ModuleBetterMine() {
        this.queue = new ArrayList<>();
    }

    @Override
    public void onSetting() {
        settingPacketDelay.setEnabled(settingBreakMode.getValue() == BreakMode.PACKET);
        settingQueueLimit.setEnabled(settingQueue.getValue());

        this.tracker.setDelay(settingPacketDelay.getValue().intValue());
    }

    @Listener
    public void onListenClientTickEvent(ClientTickEvent event) {
        if (NullUtil.isPlayerWorld()) {
            return;
        }

        boolean flag = settingOnlyPickaxe.getValue() ? (ItemUtil.contains(ItemUtil.ALL_PICKAXES, mc.player.getHeldItemMainhand().getItem())) : true;

        for (BlockDamage blocksToBreak : new ArrayList<>(this.queue)) {
            BlockDamage block = blocksToBreak;
            BlockPos position = block.getPos();

            if (this.queue.isEmpty()) {
                continue;
            }

            if (flag == false && BlockUtil.isAir(this.queue.get(0).getPos())) {
                this.queue.remove(this.queue.get(0));
            }

            // We remove if range is out.
            if (PlayerUtil.getBlockPos().getDistance(position.getX(), position.getY(), position.getZ()) >= ModuleAntiCheat.getRange() || (BlockUtil.isAir(position) && (PositionUtil.collideBlockPos(this.queue.get(0).getPos(), position) == false))) {
                if (settingBreakMode.getValue() == BreakMode.PACKET) {
                    this.tracker.send(new PlayerAbortBreakBlockTracker(block));
                }

                this.queue.remove(blocksToBreak);
            }
        }

        if (mc.player.isCreative() || flag == false) {
            return;
        }

        // I don't want spam in tracker.
        if (this.queue.isEmpty()) {
            this.tracker.clear();
        } else {
            BlockDamage block = this.queue.get(0);
            BlockPos position = block.getPos();

            if (PlayerUtil.getBlockPos().getDistance(position.getX(), position.getY(), position.getZ()) >= 5) {
                mc.playerController.resetBlockRemoving();

                this.queue.remove(block);
            }

            float k = BlockUtil.getHardness(position);

            if (k == -1 || BlockUtil.isAir(position)) {
                this.currentBlockDamageMP = 0f;

                this.tracker.clear();
                this.queue.remove(0);
            } else {
                this.doBreak(block);
            }
        }

        for (BlockDamage blocksToBreak : new ArrayList<>(this.queue)) {
            BlockDamage block = blocksToBreak;
            BlockPos position = block.getPos();

            // We remove if range is out.
            if (PlayerUtil.getBlockPos().getDistance(position.getX(), position.getY(), position.getZ()) >= ModuleAntiCheat.getRange() || BlockUtil.isAir(position)) {
                mc.playerController.resetBlockRemoving();

                this.queue.remove(blocksToBreak);
            }
        }

        /*
         * Control type of hit.
         */
        RayTraceResult blockRay = mc.player.rayTrace(ModuleAntiCheat.getRange(), mc.getRenderPartialTicks());
        Entity entityRay = mc.entityRenderer.pointedEntity;

        // Collect block.
        if (blockRay != null && blockRay.typeOfHit == RayTraceResult.Type.BLOCK) {
            BlockPos currentBlockHit = blockRay.getBlockPos();

            if (BlockUtil.isUnbreakable(currentBlockHit) || BlockUtil.isAir(currentBlockHit)) {
                return;
            }

            boolean isAccepted = true;

            if (entityRay != null && settingNoEntityTrace.getValue() == false) {
                isAccepted = false;
            }

            if (mc.gameSettings.keyBindAttack.isKeyDown() && isAccepted) {
                this.doCollect(currentBlockHit, blockRay.sideHit);
            }
        }
    }

    @Override
    public void onRender3D() {
        for (BlockDamage damage : this.queue) {
            RenderUtil.render3DSolid(camera, damage.getPos(), new Color(0, 255, 0, 100));
            RenderUtil.render3DOutline(camera, damage.getPos(), new Color(0, 255, 0, 255));
        }
    }

    @Override
    public void onEnable() {
        this.queue.clear();
        this.tracker.clear();
        this.tracker.register();
    }

    @Override
    public void onDisable() {
        this.queue.clear();
        this.tracker.clear();
        this.tracker.unregister();
    }

    public void doBreak(BlockDamage block) {
        switch ((BreakMode) settingBreakMode.getValue()) {
            case PACKET: {
                this.tracker.join(new PlayerStartBreakBlockTracker(EnumHand.MAIN_HAND, block));
                this.tracker.join(new PlayerStopBreakBlockTracker(block));

                break;
            }

            case DAMAGE: {
                this.currentBlockDamageMP += BlockUtil.getState(block.getPos()).getPlayerRelativeBlockHardness(this.mc.player, this.mc.player.world, block.getPos());

                this.tracker.send(new PlayerStartBreakBlockTracker(EnumHand.MAIN_HAND, block));
                this.tracker.send(new PlayerStopBreakBlockTracker(block));

                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.world.sendBlockBreakProgress(this.mc.player.getEntityId(), block.getPos(), (int)(this.currentBlockDamageMP * 10.0F) - 1);

                break;
            }
        }
    }

    public void doCollect(BlockPos position, EnumFacing facing) {
        BlockDamage block = new BlockUtil.BlockDamage(position, facing);

        if (this.contains(block.getPos()) || BlockUtil.isUnbreakable(position)) {
            return;
        }

        if (settingQueue.getValue()) {
            if (this.queue.size() < settingQueueLimit.getValue().intValue()) {
                this.queue.add(block);
            }
        } else {
            this.tracker.clear();
            this.queue.clear();
            this.queue.add(block);
        }
    }

    public boolean contains(BlockPos pos) {
        for (BlockDamage blocks : this.queue) {
            if (PositionUtil.collideBlockPos(pos, blocks.getPos())) {
                return true;
            }
        }

        return false;
    }
}
